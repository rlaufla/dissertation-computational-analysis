{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f98df73c",
   "metadata": {},
   "outputs": [],
   "source": [
    "pip install kiwipiepy"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "91d9737d",
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "import json\n",
    "from pathlib import Path\n",
    "\n",
    "import pandas as pd\n",
    "from kiwipiepy import Kiwi\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "\n",
    "\n",
    "# ===================== 경로/파일 설정 =====================\n",
    "# 이 스크립트 파일 기준으로 상위 폴더를 프로젝트 루트로 가정\n",
    "PROJECT_ROOT = Path(__file__).resolve().parents[1]\n",
    "\n",
    "DATA_DIR = PROJECT_ROOT / \"data\"\n",
    "OUTPUT_DIR = PROJECT_ROOT / \"results\"\n",
    "OUTPUT_DIR.mkdir(parents=True, exist_ok=True)\n",
    "\n",
    "SENTI_PATH = DATA_DIR / \"SentiWord_info.json\"\n",
    "\n",
    "# 분석에 사용할 입력 텍스트 파일들 (data 폴더 안에 있다고 가정)\n",
    "INPUT_FILES = [\n",
    "    (\"type3_스크린미디어기사_질적분석용.txt\", \"screen_media\"),\n",
    "    (\"non_screen_media기사모음.txt\", \"non_screenmedia\"),\n",
    "]\n",
    "# =========================================================\n",
    "\n",
    "\n",
    "def load_sentiment_lexicon(path: Path) -> dict:\n",
    "    \"\"\"JSON 형식 감성사전을 로드해서 {단어: 극성} 딕셔너리로 반환.\"\"\"\n",
    "    with open(path, encoding=\"utf-8-sig\") as f:\n",
    "        senti_dict = json.load(f)\n",
    "    return {item[\"word\"]: int(item[\"polarity\"]) for item in senti_dict}\n",
    "\n",
    "\n",
    "def analyze_files(input_files, senti_lookup: dict) -> pd.DataFrame:\n",
    "    \"\"\"텍스트 파일들을 KIWI로 토크나이즈해서 감성단어 기록 DataFrame을 생성.\"\"\"\n",
    "    kiwi = Kiwi()\n",
    "    records = []\n",
    "\n",
    "    for filename, label in input_files:\n",
    "        filepath = DATA_DIR / filename\n",
    "        with open(filepath, encoding=\"utf-8\") as f:\n",
    "            text = f.read()\n",
    "\n",
    "        tokens = kiwi.tokenize(text)\n",
    "\n",
    "        for token in tokens:\n",
    "            word = token.form\n",
    "            tag = token.tag\n",
    "\n",
    "            # 동사/형용사 원형 맞추기 (예: '좋' -> '좋다')\n",
    "            if tag.startswith(\"VV\") or tag.startswith(\"VA\"):\n",
    "                word += \"다\"\n",
    "\n",
    "            if word in senti_lookup:\n",
    "                score = senti_lookup[word]\n",
    "                records.append(\n",
    "                    {\n",
    "                        \"파일\": filename,\n",
    "                        \"유형\": label,\n",
    "                        \"단어\": word,\n",
    "                        \"극성\": score,\n",
    "                    }\n",
    "                )\n",
    "\n",
    "    return pd.DataFrame(records)\n",
    "\n",
    "\n",
    "def plot_average_sentiment(df: pd.DataFrame, output_dir: Path):\n",
    "    \"\"\"유형별 평균 감성 점수를 막대그래프로 저장.\"\"\"\n",
    "    type_mapping = {\n",
    "        \"screen_media\": \"articles on screen media\",\n",
    "        \"non_screenmedia\": \"straight articles\",\n",
    "    }\n",
    "    df[\"type\"] = df[\"유형\"].map(type_mapping)\n",
    "\n",
    "    avg_df = df.groupby(\"type\")[\"극성\"].mean().reset_index()\n",
    "\n",
    "    plt.figure(figsize=(8, 5))\n",
    "    sns.barplot(data=avg_df, x=\"type\", y=\"극성\", width=0.5)\n",
    "    plt.axhline(0, linestyle=\"--\")\n",
    "    plt.title(\"Average Sentiment Score by Type\")\n",
    "    plt.ylabel(\"Average Sentiment Score\")\n",
    "    plt.xlabel(\"Type\")\n",
    "    plt.tight_layout()\n",
    "\n",
    "    out_path = output_dir / \"avg_sentiment_score_by_type.png\"\n",
    "    plt.savefig(out_path, dpi=300)\n",
    "    plt.close()\n",
    "\n",
    "\n",
    "def main():\n",
    "    # 감성사전 로드\n",
    "    senti_lookup = load_sentiment_lexicon(SENTI_PATH)\n",
    "\n",
    "    # 텍스트 파일 분석\n",
    "    sent_df = analyze_files(INPUT_FILES, senti_lookup)\n",
    "\n",
    "    # CSV로 저장\n",
    "    csv_path = OUTPUT_DIR / \"감성단어_기록.csv\"\n",
    "    sent_df.to_csv(csv_path, index=False, encoding=\"utf-8-sig\")\n",
    "\n",
    "    # 시각화 및 그림 저장\n",
    "    plot_average_sentiment(sent_df, OUTPUT_DIR)\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0ee26622",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pandas as pd\n",
    "from itertools import product\n",
    "from pathlib import Path\n",
    "\n",
    "\n",
    "# 1. Load data\n",
    "\n",
    "def load_data(path: Path) -> pd.DataFrame:\n",
    "    \"\"\"Load sentiment score Excel file.\"\"\"\n",
    "    return pd.read_excel(path)\n",
    "\n",
    "\n",
    "# 2. Cliff's Delta calculation\n",
    "\n",
    "\n",
    "def cliffs_delta(lst1, lst2):\n",
    "    \"\"\"\n",
    "    Calculate Cliff's Delta effect size.\n",
    "    δ = (number of lst1 > lst2 pairs - number of lst1 < lst2 pairs) / (n1 * n2)\n",
    "    \"\"\"\n",
    "    n1, n2 = len(lst1), len(lst2)\n",
    "    gt = sum(1 for x, y in product(lst1, lst2) if x > y)\n",
    "    lt = sum(1 for x, y in product(lst1, lst2) if x < y)\n",
    "    delta = (gt - lt) / (n1 * n2)\n",
    "    return delta\n",
    "\n",
    "\n",
    "def interpret_cliffs_delta(delta):\n",
    "    \"\"\"Interpret Cliff's Delta according to common thresholds.\"\"\"\n",
    "    abs_d = abs(delta)\n",
    "    if abs_d < 0.147:\n",
    "        return \"negligible\"\n",
    "    elif abs_d < 0.33:\n",
    "        return \"small\"\n",
    "    elif abs_d < 0.474:\n",
    "        return \"medium\"\n",
    "    else:\n",
    "        return \"large\"\n",
    "\n",
    "\n",
    "# 3. Main execution\n",
    "\n",
    "def main():\n",
    "    # Path for GitHub-friendly relative location\n",
    "    data_path = Path(\"data/sentiment_input.xlsx\")\n",
    "\n",
    "    df = load_data(data_path)\n",
    "\n",
    "    # Extract groups by Type\n",
    "    group1 = df[df[\"Type\"] == 1][\"평균감성점수\"].dropna().tolist()  # non-screen\n",
    "    group2 = df[df[\"Type\"] == 2][\"평균감성점수\"].dropna().tolist()  # screen\n",
    "\n",
    "    # Effect size calculation\n",
    "    delta = cliffs_delta(group2, group1)\n",
    "    effect = interpret_cliffs_delta(delta)\n",
    "\n",
    "    print(f\"Cliff's delta: {delta:.4f}\")\n",
    "    print(f\"Effect size interpretation: {effect}\")\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "ae36f479",
   "metadata": {},
   "outputs": [],
   "source": [
    "from pathlib import Path\n",
    "\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import seaborn as sns\n",
    "import scipy.stats as stats\n",
    "from scipy.stats import mannwhitneyu, shapiro, levene, ttest_ind\n",
    "\n",
    "\n",
    "# 1. Helper functions\n",
    "\n",
    "def classify_media_type(t: int) -> str:\n",
    "    \"\"\"\n",
    "    Map numeric Type value to media_type label.\n",
    "\n",
    "    1, 2 -> 'non screen media'\n",
    "    3    -> 'screen media'\n",
    "    else -> 'unknown'\n",
    "    \"\"\"\n",
    "    if t in [1, 2]:\n",
    "        return \"non screen media\"\n",
    "    elif t == 3:\n",
    "        return \"screen media\"\n",
    "    return \"unknown\"\n",
    "\n",
    "\n",
    "def run_analysis(df: pd.DataFrame):\n",
    "    \"\"\"\n",
    "    Run normality tests, homogeneity test, and group comparison.\n",
    "    Prints all results and returns (stat, p).\n",
    "    \"\"\"\n",
    "\n",
    "    df = df[df[\"media_type\"] != \"unknown\"].copy()\n",
    "\n",
    "\n",
    "    non_screen = df[df[\"media_type\"] == \"non screen media\"][\"평균감성점수\"]\n",
    "    screen = df[df[\"media_type\"] == \"screen media\"][\"평균감성점수\"]\n",
    "\n",
    "    print(f\"\\n샘플 수 - non screen: {len(non_screen)}, screen: {len(screen)}\")\n",
    "\n",
    "\n",
    "    stat_ns, p_ns = shapiro(non_screen)\n",
    "    stat_s, p_s = shapiro(screen)\n",
    "    print(\"\\n[정규성 검정 - Shapiro-Wilk]\")\n",
    "    print(f\"  non screen media: p = {p_ns:.4f}\")\n",
    "    print(f\"  screen media    : p = {p_s:.4f}\")\n",
    "\n",
    "\n",
    "    stat_lev, p_lev = levene(non_screen, screen)\n",
    "    print(\"\\n[등분산성 검정 - Levene]\")\n",
    "    print(f\"  p = {p_lev:.4f}\")\n",
    "\n",
    "\n",
    "    print(\"\\n[통계적 비교]\")\n",
    "    if len(screen) < 10 or len(non_screen) < 10:\n",
    "        stat, p = mannwhitneyu(non_screen, screen, alternative=\"two-sided\")\n",
    "        print(\"  → [샘플 수 적음] Mann-Whitney U test 적용\")\n",
    "    elif p_ns > 0.05 and p_s > 0.05:\n",
    "        if p_lev > 0.05:\n",
    "            stat, p = ttest_ind(non_screen, screen, equal_var=True)\n",
    "            print(\"  → Student's t-test 적용\")\n",
    "        else:\n",
    "            stat, p = ttest_ind(non_screen, screen, equal_var=False)\n",
    "            print(\"  → Welch's t-test 적용\")\n",
    "    else:\n",
    "        stat, p = mannwhitneyu(non_screen, screen, alternative=\"two-sided\")\n",
    "        print(\"  → Mann-Whitney U test 적용 (정규성 불만족)\")\n",
    "\n",
    "    print(f\"  통계량 = {stat:.4f}, p-value = {p:.4f}\")\n",
    "\n",
    "    return df, non_screen, screen, stat, p\n",
    "\n",
    "\n",
    "def create_summary_table(df: pd.DataFrame) -> pd.DataFrame:\n",
    "    \"\"\"type별 평균감성점수 요약 통계표 생성.\"\"\"\n",
    "    summary = (\n",
    "        df.groupby(\"media_type\")[\"평균감성점수\"]\n",
    "        .agg(N=\"count\", Mean=\"mean\", Median=\"median\", SD=\"std\", Min=\"min\", Max=\"max\")\n",
    "        .reset_index()\n",
    "        .round(4)\n",
    "    )\n",
    "    print(\"\\n[요약 통계표]\")\n",
    "    print(summary)\n",
    "    return summary\n",
    "\n",
    "\n",
    "def plot_boxplot(df: pd.DataFrame, save_path: Path):\n",
    "    \"\"\"Boxplot: 평균 감성점수 by Media Type.\"\"\"\n",
    "    plt.figure(figsize=(6, 4))\n",
    "    sns.boxplot(data=df, x=\"media_type\", y=\"평균감성점수\")\n",
    "    plt.title(\"Boxplot: 평균 감성점수 by Media Type\")\n",
    "    plt.xlabel(\"Media Type\")\n",
    "    plt.ylabel(\"평균 감성점수\")\n",
    "    plt.tight_layout()\n",
    "    plt.savefig(save_path, dpi=300)\n",
    "    plt.close()\n",
    "\n",
    "\n",
    "def plot_qq(data, title: str, save_path: Path):\n",
    "    \"\"\"Q-Q plot 저장.\"\"\"\n",
    "    plt.figure(figsize=(6, 4))\n",
    "    stats.probplot(data, dist=\"norm\", plot=plt)\n",
    "    plt.title(title)\n",
    "    plt.tight_layout()\n",
    "    plt.savefig(save_path, dpi=300)\n",
    "    plt.close()\n",
    "\n",
    "\n",
    "# 2. Main\n",
    "\n",
    "\n",
    "def main():\n",
    "\n",
    "    repo_root = Path(__file__).resolve().parents[1]\n",
    "    data_dir = repo_root / \"data\"\n",
    "    results_dir = repo_root / \"results\"\n",
    "    results_dir.mkdir(exist_ok=True)\n",
    "\n",
    "    data_path = data_dir / \"data.xlsx\"\n",
    "\n",
    "    # 데이터 로드\n",
    "    df = pd.read_excel(data_path)\n",
    "\n",
    "    # Type → media_type 분류\n",
    "    df[\"media_type\"] = df[\"Type\"].apply(classify_media_type)\n",
    "\n",
    "    # 분석 실행\n",
    "    df_clean, non_screen, screen, stat, p = run_analysis(df)\n",
    "\n",
    "    # 요약표 생성\n",
    "    summary_table = create_summary_table(df_clean)\n",
    "\n",
    "    # 결과 저장\n",
    "    summary_path = results_dir / \"sentiment_summary_by_type.xlsx\"\n",
    "    summary_table.to_excel(summary_path, index=False)\n",
    "    print(f\"\\n 요약표 저장 완료: {summary_path}\")\n",
    "\n",
    "    # 시각화 저장\n",
    "    plot_boxplot(df_clean, results_dir / \"boxplot_sentiment.png\")\n",
    "    plot_qq(non_screen, \"Q-Q Plot: Non Screen Media\", results_dir / \"qqplot_non_screen.png\")\n",
    "    plot_qq(screen, \"Q-Q Plot: Screen Media\", results_dir / \"qqplot_screen.png\")\n",
    "\n",
    "    print(f\" 그래프 저장 완료: {results_dir}\")\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "aac8e981",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.10.9"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
